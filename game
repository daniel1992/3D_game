#include "../../shared/gltools.h"	// OpenGL toolkit
#include "../../shared/math3d.h"    // 3D Math Library
#include "../../shared/glframe.h"   // Frame class
#include <math.h>
#include "glm.h"

//蟲子
//Update.2013/12/29:完成基本運動方式，改寫成class

class bug
{
public:
    bug();
    ~bug();
    void action();
    void attack(int i);
    void drawbug(int i);
    void attacked(int i);
    void crawl(int i);
    void die(int i);
    int sattack;
    int sattacked;
    int scrawl;
    int sdie;
    float angle[6][5];
private:
    float flip;
    float movex;
    float movey;
    float movez;
    int head;
    int antenna;
    int attacktimer;
    int attackedtimer;
    int dietimer;
    int crawltimer;


};
bug::bug(){
    flip=0;
    sdie=0;
    scrawl=0;
    dietimer=0;
    crawltimer=0;
    attacktimer=0;
    attackedtimer=0;
    movex=0;
    movey=0;
    movez=0;
    head=0;
    antenna=-30;
    sattack=0;
    for(int i=0; i<6; i++)
    {
        if(i==0||i==3)
        {
            angle[i][0]=-30;
        }
        else if(i==1||i==4)
        {
            angle[i][0]=0;
        }
        else
        {
            angle[i][0]=30;
        }
        angle[i][1]=-20;
        angle[i][2]=60;
        angle[i][3]=50;
        angle[i][4]=0;
    }
}
bug::~bug(){}
void bug::drawbug(int color)
{

    float x,y,z,x2,y2,y3,y4,z2,z3,z4;
    float rad=3.14159/180.0;

    if(color == 0)
        glColor3ub(128, 128, 128);
    else
        glColor3ub(0,0,0);

    M3DVector3f vNormal;

    glLineWidth(1.5);

    glTranslatef(movex,movey,movez);

    //glutSolidSphere(0.5,10,10);

    glRotatef(flip,0,1,0);


    glBegin(GL_QUAD_STRIP);//body

    for(int i=5; i<=135; i+=5)
    {

        x=0.4*cos(rad*i);
        x2=0.4*cos(rad*(i-5));
        for(int j=5; j<360; j+=5)
        {

            if(j<=180)
            {
                y=0.25*sin(rad*i)*cos(rad*j);
                y2=0.25*sin(rad*(i-5))*cos(rad*j);
                y3=0.25*sin(rad*(i))*cos(rad*(j-5));
                y4=0.25*sin(rad*(i-5))*cos(rad*(j-5));
                z=0.25*sin(rad*i)*0.8*sin(rad*j);
                z2=0.25*sin(rad*(i-5))*0.8*sin(rad*j);
                z3=0.25*sin(rad*(i))*0.8*sin(rad*(j-5));
                z4=0.25*sin(rad*(i-5))*0.8*sin(rad*(j-5));

            }
            else
            {
                y=0.25*sin(rad*i)*0.8*cos(rad*j);
                y2=0.25*sin(rad*(i-5))*0.8*cos(rad*j);
                y3=0.25*sin(rad*(i))*0.8*cos(rad*(j-5));
                y4=0.25*sin(rad*(i-5))*0.8*cos(rad*(j-5));
                z=0.25*sin(rad*i)*0.8*0.6*sin(rad*j);
                z2=0.25*sin(rad*(i-5))*0.8*0.6*sin(rad*j);
                z3=0.25*sin(rad*(i))*0.8*0.6*sin(rad*(j-5));
                z4=0.25*sin(rad*(i-5))*0.8*0.6*sin(rad*(j-5));
            }

            M3DVector3f vPoints[3] = {{ x, y, z },
                { x2, y4, z4 },
                { x, y3, z3 }
            };
            m3dFindNormal(vNormal, vPoints[0], vPoints[1], vPoints[2]);
            glNormal3fv(vNormal);
            glVertex3f(x,y,z);
            glVertex3f(x,y3,z3);
            glVertex3f(x2,y2,z2);
            glVertex3f(x2,y4,z4);
        }

    }

    glEnd();

    glPushMatrix();//head

    glTranslatef(0.4*cos(rad*135)-0.1*cos(rad*60),0,0);
    glRotatef(head,1,0,0);
    glutSolidSphere(0.125,13,26);
    glPushMatrix();
    glRotatef(-30,0,0,1);
    glRotatef(antenna,0,1,0);
    glTranslatef(-0.35,0.05,0.1);

    glBegin(GL_LINE_STRIP);
    for(int i=0; i<90; i+=1)
    {
        x=cos(rad*i)*0.3;
        z=sin(rad*i)*0.3;
        glVertex3f(x,0,z);
    }
    glEnd();
    glPopMatrix();
    glPushMatrix();
    glRotatef(30,0,0,1);
    glRotatef(antenna,0,1,0);
    glTranslatef(-0.35,-0.05,0.1);
    glBegin(GL_LINE_STRIP);
    for(int i=0; i<90; i+=1)
    {
        x=cos(rad*i)*0.3;
        z=sin(rad*i)*0.3;
        glVertex3f(x,0,z);
    }
    glEnd();
    glPopMatrix();

    glPopMatrix();

    //legs

    glPushMatrix();
    glTranslatef(0.4*cos(rad*120)+0.07,0.25*0.8*sin(rad*120)*cos(rad*225)+0.03,0.25*0.8*0.6*sin(rad*120)*cos(rad*225)+0.02);
    glRotatef(angle[0][0],0,0,1);
    glRotatef(angle[0][1],1,0,0);
    glRotatef(angle[0][4],0,1,0);
    glTranslatef(0,-0.1,0);
    glPushMatrix();
    glScalef(0.05,0.2,0.05);
    glutSolidCube(1);
    glPopMatrix();
    glTranslatef(0,-0.1,0);
    glRotatef(angle[0][2],1,0,0);
    glTranslatef(0,-0.1,0);
    glPushMatrix();
    glScalef(0.05,0.2,0.05);
    glutSolidCube(1);
    glPopMatrix();
    glTranslatef(0,-0.1,0);
    glRotatef(angle[0][3],1,0,0);
    glRotatef(90,1,0,0);
    glutSolidCone(0.04,0.2,10,10);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(0.4*cos(rad*90)+0.03,0.25*0.8*sin(rad*90)*cos(rad*225)+0.03,0.25*0.8*0.6*sin(rad*90)*cos(rad*225)+0.02);
    glRotatef(angle[1][0],0,0,1);
    glRotatef(angle[1][1],1,0,0);
    glRotatef(angle[1][4],0,1,0);
    glTranslatef(0,-0.1,0);
    glPushMatrix();
    glScalef(0.05,0.2,0.05);
    glutSolidCube(1);
    glPopMatrix();
    glTranslatef(0,-0.1,0);
    glRotatef(angle[1][2],1,0,0);
    glTranslatef(0,-0.1,0);
    glPushMatrix();
    glScalef(0.05,0.2,0.05);
    glutSolidCube(1);
    glPopMatrix();
    glTranslatef(0,-0.1,0);
    glRotatef(angle[1][3],1,0,0);
    glRotatef(90,1,0,0);
    glutSolidCone(0.04,0.2,10,10);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(0.4*cos(rad*60)+0.03,0.25*0.8*sin(rad*90)*cos(rad*225)+0.03,0.25*0.8*0.6*sin(rad*90)*cos(rad*225)+0.02);
    glRotatef(angle[2][0],0,0,1);
    glRotatef(angle[2][1],1,0,0);
    glRotatef(angle[2][4],0,1,0);
    glTranslatef(0,-0.1,0);
    glPushMatrix();
    glScalef(0.05,0.2,0.05);
    glutSolidCube(1);
    glPopMatrix();
    glTranslatef(0,-0.1,0);
    glRotatef(angle[2][2],1,0,0);
    glTranslatef(0,-0.1,0);
    glPushMatrix();
    glScalef(0.05,0.2,0.05);
    glutSolidCube(1);
    glPopMatrix();
    glTranslatef(0,-0.1,0);
    glRotatef(angle[2][3],1,0,0);
    glRotatef(90,1,0,0);
    glutSolidCone(0.04,0.2,10,10);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(0.4*cos(rad*60)+0.03,-(0.25*0.8*sin(rad*90)*cos(rad*225)+0.03),0.25*0.8*0.6*sin(rad*90)*cos(rad*225)+0.02);
    glRotatef(angle[3][0],0,0,1);
    glRotatef(-angle[3][1],1,0,0);
    glRotatef(angle[3][4],0,1,0);
    glTranslatef(0,0.1,0);
    glPushMatrix();
    glScalef(0.05,-0.2,0.05);
    glutSolidCube(1);
    glPopMatrix();
    glTranslatef(0,0.1,0);
    glRotatef(-angle[3][2],1,0,0);
    glTranslatef(0,0.1,0);
    glPushMatrix();
    glScalef(0.05,0.2,0.05);
    glutSolidCube(1);
    glPopMatrix();
    glTranslatef(0,0.1,0);
    glRotatef(-angle[3][3],1,0,0);
    glRotatef(-90,1,0,0);
    glutSolidCone(0.04,0.2,10,10);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(0.4*cos(rad*90)+0.03,-(0.25*0.8*sin(rad*90)*cos(rad*225)+0.03),0.25*0.8*0.6*sin(rad*90)*cos(rad*225)+0.02);
    glRotatef(angle[4][0],0,0,1);
    glRotatef(-angle[4][1],1,0,0);
    glRotatef(angle[4][4],0,1,0);
    glTranslatef(0,0.1,0);
    glPushMatrix();
    glScalef(0.05,-0.2,0.05);
    glutSolidCube(1);
    glPopMatrix();
    glTranslatef(0,0.1,0);
    glRotatef(-angle[4][2],1,0,0);
    glTranslatef(0,0.1,0);
    glPushMatrix();
    glScalef(0.05,0.2,0.05);
    glutSolidCube(1);
    glPopMatrix();
    glTranslatef(0,0.1,0);
    glRotatef(-angle[4][3],1,0,0);
    glRotatef(-90,1,0,0);
    glutSolidCone(0.04,0.2,10,10);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(0.4*cos(rad*120)+0.07,-(0.25*0.8*sin(rad*90)*cos(rad*225)+0.03),0.25*0.8*0.6*sin(rad*90)*cos(rad*225)+0.02);
    glRotatef(angle[5][0],0,0,1);
    glRotatef(-angle[5][1],1,0,0);
    glRotatef(angle[5][4],0,1,0);
    glTranslatef(0,0.1,0);
    glPushMatrix();
    glScalef(0.05,-0.2,0.05);
    glutSolidCube(1);
    glPopMatrix();
    glTranslatef(0,0.1,0);
    glRotatef(-angle[5][2],1,0,0);
    glTranslatef(0,0.1,0);
    glPushMatrix();
    glScalef(0.05,0.2,0.05);
    glutSolidCube(1);
    glPopMatrix();
    glTranslatef(0,0.1,0);
    glRotatef(-angle[5][3],1,0,0);
    glRotatef(-90,1,0,0);
    glutSolidCone(0.04,0.2,10,10);
    glPopMatrix();


}
void bug::action(){
    if(sdie==1) {
        die(dietimer);
    }
    else if(sattacked==1) {
        attacked(attackedtimer);
    }
    else if(sattack==1) {
        attack(attacktimer);
    }
    else if(scrawl=1){
        crawl(crawltimer);
    }
}
void bug::attack(int i) {

    if(i<50) {

        if(i<25) {
            movex-=0.006;
            for(int j=0;j<6;j++) {

                    angle[j][4]-=0.6;

            }
        }
        else {
            movex+=0.006;
            for(int j=0;j<6;j++) {

                    angle[j][4]+=0.6;

            }
        }
        attacktimer++;

    }
    else {
        attacktimer=0;
        sattack=0;
    }
    glutPostRedisplay();
}
void bug::attacked(int i) {

    if(i<100) {

        if(i<25) {
            movex+=0.006;
            for(int j=0;j<6;j++) {

                    angle[j][4]+=0.6;

            }
        }
        else if(i<75) {

        }
        else {
            movex-=0.006;
            for(int j=0;j<6;j++) {

                    angle[j][4]-=0.6;

            }
        }
        attackedtimer++;

    }
    else {
        sattacked=0;
        attackedtimer=0;
    }
    glutPostRedisplay();
}
void bug::die(int i)
{
    if(i<200)
    {
        if(i<50)
        {
            flip=3.6*i;
        }
        else
        {
            flip=180;
            for(int j=0; j<6; j++)
            {
                if(j%2==0)
                {
                    angle[j][2]=60+30*sin(0.314159*2/5*i);
                    angle[j][3]=50+30*sin(0.314159*2/5*i);
                }
                else{
                    angle[j][2]=60-30*sin(0.314159*2/5*i);
                    angle[j][3]=50-30*sin(0.314159*2/5*i);
                }
            }
        }
        dietimer++;
        //shadow.RotateLocalZ(3.14159/20.0);
    }
    else {
        sdie=0;
        flip=0;
        dietimer=0;
            for(int i=0; i<6; i++)
    {
        if(i==0||i==3)
        {
            angle[i][0]=-30;
        }
        else if(i==1||i==4)
        {
            angle[i][0]=0;
        }
        else
        {
            angle[i][0]=30;
        }
        angle[i][1]=-20;
        angle[i][2]=60;
        angle[i][3]=50;
        angle[i][4]=0;
    }
    }
    glutPostRedisplay();
}
void bug::crawl(int i)
{

    float t=1;

    if(i<60)
    {

        t=2*sin(3.14159/30*i);


        angle[0][0]=-30+10*t;
        angle[2][0]=60+10*t;
        angle[3][0]=-60+10*t;
        angle[5][0]=30+10*t;
        angle[1][0]=10-8*t;
        angle[4][0]=-10-8*t;
        angle[5][1]=-20-10*t;
        angle[5][2]=60+5*t;
        angle[5][3]=50+5*t;
        angle[5][4]=4*t;
        angle[4][1]=-20+5*t;
        //angle[4][2]=60+5*t;
        //angle[4][3]=50+5*t;
        angle[4][4]=-10*t;
        angle[3][1]=-20-10*t;
        angle[3][2]=60+5*t;
        angle[3][3]=50+5*t;
        angle[3][4]=2*t;
        angle[0][1]=-20+10*t;
        angle[0][2]=60+5*t;
        angle[0][3]=50+5*t;
        angle[0][4]=-4*t;
        angle[1][1]=-20-5*t;
        //angle[1][2]=60+5*t;
        //angle[1][3]=50+5*t;
        angle[1][4]=10*t;
        angle[2][1]=-20+10*t;
        angle[2][2]=60+5*t;
        angle[2][3]=50+5*t;
        angle[2][4]=-2*t;

        crawltimer++;

    }
    else
    {
        scrawl=0;
        crawltimer=0;
        //state=0;
    }
    glutPostRedisplay();
}


#define NUM_SPHERES      50
GLFrame    spheres[NUM_SPHERES];
GLFrame    frameCamera;
GLFrame    frametorus;
GLFrame    world;
GLFrame    shadow;

float delta=0;
float angle[6][5];
int state=0;
int cond=0;
int head=0;
int antenna=-30;
float speed=0.5f;
float xro=0.5;
float yro=0;
static GLfloat xRot = 0.0f;
static GLfloat yRot = 0.0f;
float flip=0;
float movex=0;
float movey=0;
float movez=0;

bug test[2];

GLfloat  ambientLight[] = { 0.8f, 0.8f, 0.8f, 1.0f };
GLfloat  ambientLightg[] = { 0.0f, 0.9f, 0.0f, 1.0f };
GLfloat  diffuseLight[] = { 0.7f, 0.7f, 0.7f, 1.0f };
GLfloat  diffuseLightg[] = { 0.0f, 0.5f, 0.0f, 1.0f };
GLfloat  specular[] = { 1.0f, 1.0f, 1.0f, 1.0f};
GLfloat  specularg[] = { 0.0f, 2.0f, 0.0f, 1.0f};
GLfloat	 lightPos[] = { 0.0f, 1.9f,0.8f, 0.0f };
GLfloat	 lightPos2[] = { 0.0f, 1.9f,0.8f, 1.0f };
GLfloat	 lightPos3[] = { 0.0f, 1.9f,0.8f, 1.0f };
GLfloat	 dlightPos[] = { 0.0f, 1.9f,0.8f, 0.0f };
GLfloat  specref[] =  { 1.0f, 1.0f, 1.0f, 1.0f };
float temp=lightPos[1];

M3DMatrix44f shadowMat;

GLuint  textureObjects[1];


//////////////////////////////////////////////////////////////////
// This function does any needed initialization on the rendering
// context.
void SetupRC()
{
    int iSphere;

    // Bluish background
    glClearColor(0.0f, 0.0f, .80f, 1.0f );

    // Draw everything as wire frame

    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);


    // Randomly place the sphere inhabitants

    frametorus.SetOrigin(0.0f, 0.34f, -2.5);
    world.SetOrigin(0.0f, 0.34f, -2.5);
    shadow.SetOrigin(0.0f, 0.34f, -2.5);
    frameCamera.SetOrigin(0,0.7,1.5);
    frametorus.RotateLocalX(-3.14159/2);
    world.RotateLocalX(-3.14159/2);
    shadow.RotateLocalX(-3.14159/2);

    for(int i=0; i<6; i++)
    {
        if(i==0||i==3)
        {
            angle[i][0]=-30;
        }
        else if(i==1||i==4)
        {
            angle[i][0]=0;
        }
        else
        {
            angle[i][0]=30;
        }
        angle[i][1]=-20;
        angle[i][2]=60;
        angle[i][3]=50;
        angle[i][4]=0;
    }

    glEnable(GL_DEPTH_TEST);	// Hidden surface removal
    glFrontFace(GL_CCW);		// Counter clock-wise polygons face out
    glEnable(GL_CULL_FACE);		// Do not calculate inside of jet
    glCullFace(GL_BACK);
    glEnable(GL_MULTISAMPLE_ARB);


    glLightfv(GL_LIGHT0,GL_AMBIENT,ambientLight);
    glLightfv(GL_LIGHT0,GL_DIFFUSE,diffuseLight);
    glLightfv(GL_LIGHT0,GL_SPECULAR,specular);
    glLightfv(GL_LIGHT0,GL_POSITION,lightPos);

    glEnable(GL_COLOR_MATERIAL);
    glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE);
    glMaterialfv(GL_FRONT, GL_SPECULAR,specref);
    glMateriali(GL_FRONT,GL_SHININESS,128);



    glEnable(GL_NORMALIZE);

}



///////////////////////////////////////////////////////////
// Draw a gridded ground
void DrawGround(void)
{
    GLfloat fExtent = 20.0f;
    GLfloat fStep = 1.0f;
    GLfloat y = -0.4f;
    GLint iLine;

    glBegin(GL_QUADS);

    glColor3ub(0,255,0);
    glVertex3f(-100,-100 ,-0.4 );
    glVertex3f(100, -100, -0.4);    // Draw Z lines
    glColor3ub(0,120,0);
    glVertex3f(100, 100, -0.4);
    glVertex3f(-100, 100, -0.4);

    glEnd();
}


// Called to draw scene
void RenderScene(void)
{
    int i;
    static GLfloat yRot = 0.0f;         // Rotation angle for animation


    // Clear the window with current clearing color
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);




    glEnable(GL_LIGHT0);
    glPushMatrix();//3
    frameCamera.ApplyCameraTransform();

    glColor3f(1,1,1);
    // Draw the randomly located spheres
    float x,y,z,x2,y2,y3,y4,z2,z3,z4;
    float rad=3.14159/180.0;

    glPushMatrix();//11
    world.ApplyActorTransform();
    DrawGround();
    M3DVector3f points[3] = {{ 10, -10, -0.4 },
        { -10, 10, -0.4 },
        { -10, -10, -0.4 }
    };
    M3DVector4f vPlaneEquation;
    m3dGetPlaneEquation(vPlaneEquation, points[0], points[1], points[2]);
    m3dMakePlanarShadowMatrix(shadowMat, vPlaneEquation, dlightPos);
    glPopMatrix();//11



    glLightfv(GL_LIGHT0,GL_POSITION,dlightPos);

    glPushMatrix();//shadow
    frametorus.ApplyActorTransform();
    glDisable(GL_DEPTH_TEST);
    m3dMakePlanarShadowMatrix(shadowMat, vPlaneEquation, lightPos);
    glMultMatrixf((GLfloat *)shadowMat);
    test[0].drawbug(1);
    glEnable(GL_DEPTH_TEST);
    glPopMatrix();//1



    glPushMatrix();//light source
    world.ApplyActorTransform();
    glTranslatef(dlightPos[0],dlightPos[1], dlightPos[2]);
    glColor3ub(255,255,0);
    glutSolidSphere(0.03f,10,10);
    glEnable(GL_LIGHTING);
    glLightfv(GL_LIGHT0,GL_POSITION,dlightPos);
    glPopMatrix();

    glPushMatrix();
    world.ApplyActorTransform();
    glTranslatef(1,0,0);
    test[0].drawbug(0);
    test[0].action();
    glPopMatrix();
    glPushMatrix();
    world.ApplyActorTransform();
    glTranslatef(-1,0,0);
    glRotatef(180,0,0,1);
    test[1].drawbug(0);
    test[1].action();
    glDisable(GL_LIGHTING);
    glPopMatrix();//2








    glPopMatrix();//3







    // Do the buffer Swap
    glutSwapBuffers();
}
void myKeys(unsigned char key, int x, int y)
{
    switch(key)
    {

    case '+':
        lightPos[2]+=0.1;
        break;
    case '-':
        lightPos[2]-=0.1;
        break;
    case '*':
        lightPos[1]+=0.1;
        temp+=0.1;
        dlightPos[1]+=0.1;
        break;
    case '/':
        lightPos[1]-=0.1;
        temp-=0.1;
        dlightPos[1]-=0.1;
        break;

    case 'i':
        world.RotateLocalY(0.1f);
        //Ex:  frametorus.????
        break;
    case 'k':
        world.RotateLocalY(-0.1f);


        break;
    case 'j':
        world.RotateLocalZ(0.1f);

        break;
    case 'l':
        world.RotateLocalZ(-0.1f);

        break;
    case 'u':
        world.RotateLocalX(0.1f);

        break;
    case 'o':
        world.RotateLocalX(-0.1f);

        break;

    case 'z':
        angle[5][1]=-20;
        angle[5][2]=60;
        angle[5][3]=50;
        break;

    case'q':
        test[0].sdie=1;
        /*if(state==0)
        {
            angle[1][0]=0;
            angle[4][0]=0;
            angle[0][0]=-30;
            angle[3][0]=-30;
            angle[2][0]=30;
            angle[5][0]=30;
            state=1;
            die(0);
        }*/
        break;
    case'e':
        test[0].sattacked=1;
        /*if(state==0)
        {
            angle[1][0]=0;
            angle[4][0]=0;
            angle[0][0]=-30;
            angle[3][0]=-30;
            angle[2][0]=30;
            angle[5][0]=30;
            state=1;
            attacked(0);
        }*/
        break;
    case' ':
        test[0].scrawl=1;
        /*if(state==0)
        {
            state=1;
            angle[1][0]=15;
            angle[4][0]=15;
            angle[0][0]=-45;
            angle[2][0]=10;
            angle[5][0]=10;
            angle[3][0]=-45;
            crawl(0);
            angle[1][0]=0;
            angle[4][0]=0;
            angle[0][0]=-30;
            angle[3][0]=-30;
            angle[2][0]=30;
            angle[5][0]=30;
        }*/
        break;
    case 'r':
        if(state==0)
        {
            state=1;
            angle[1][0]=0;
            angle[4][0]=0;
            angle[0][0]=-30;
            angle[3][0]=-30;
            angle[2][0]=30;
            angle[5][0]=30;
            //roll(0);
        }
        break;

    case 'w':
        xro+=0.1;
        //frametorus.MoveRight(-0.1f);
        break;
    case 's':
        xro-=0.1;
        //frametorus.MoveRight(0.1f);
        break;
    case 'a':
        yro+=0.1;
        //frametorus.MoveUp(-0.1f);
        break;
    case 'd':
        yro-=0.1;
        //frametorus.MoveUp(0.1f);
        break;
    case '1':
        if(head<90)
            head+=2;
        break;
    case '2':
        if(head>-90)
            head-=2;
        break;
    case '3':
        if(antenna<40)
            antenna+=2;
        break;
    case '4':
        if(antenna>-90)
            antenna-=2;
        break;

    case 't':
        if(angle[5][1]>-40)
            angle[5][1]-=2;
        break;
    case 'y':
        if(angle[5][1]<40)
            angle[5][1]+=2;
        break;
    case 'g':
        if(angle[5][2]>0)
            angle[5][2]-=2;
        break;
    case 'h':
        if(angle[5][2]<120)
            angle[5][2]+=2;
        break;
    case 'b':
        if(angle[5][3]>0)
            angle[5][3]-=2;
        break;
    case 'n':
        if(angle[5][3]<90)
            angle[5][3]+=2;
        break;
    case 'c':
        test[0].sattack=1;
        /*if(state==0)
        {
            angle[1][0]=0;
            angle[4][0]=0;
            angle[0][0]=-30;
            angle[3][0]=-30;
            angle[2][0]=30;
            angle[5][0]=30;
            state=1;
            attack(0);
        }*/
        break;
    }
    glutPostRedisplay();
}


// Respond to arrow keys by moving the camera frame of reference
void SpecialKeys(int key, int x, int y)
{
    if(key == GLUT_KEY_UP)
        frameCamera.MoveForward(0.1f);
    //xRot -= 5.0f;


    if(key == GLUT_KEY_DOWN)
        frameCamera.MoveForward(-0.1f);
    //xRot += 5.0f;

    if(key == GLUT_KEY_LEFT)
        frameCamera.RotateLocalY(0.1f);
    //yRot -= 5.0f;

    if(key == GLUT_KEY_RIGHT)
        frameCamera.RotateLocalY(-0.1f);
    //yRot += 5.0f;


    // Refresh the Window
    glutPostRedisplay();
}



///////////////////////////////////////////////////////////
// Called by GLUT library when idle (window not being
// resized or moved)
void TimerFunction(int value)
{
    // Redraw the scene with new coordinates
    glutPostRedisplay();
    glutTimerFunc(3,TimerFunction, 1);
}

void ChangeSize(int w, int h)
{
    GLfloat fAspect;

    // Prevent a divide by zero, when window is too short
    // (you cant make a window of zero width).
    if(h == 0)
        h = 1;

    glViewport(0, 0, w, h);

    fAspect = (GLfloat)w / (GLfloat)h;

    // Reset the coordinate system before modifying
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();

    // Set the clipping volume
    gluPerspective(35.0f, fAspect, 1.0f, 50.0f);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

int main(int argc, char* argv[])
{
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
    glutInitWindowSize(800,600);
    glutCreateWindow("OpenGL BugsWorld Demo");
    glutReshapeFunc(ChangeSize);
    glutDisplayFunc(RenderScene);
    glutKeyboardFunc(myKeys);
    glutSpecialFunc(SpecialKeys);

    SetupRC();
    glutTimerFunc(33, TimerFunction, 1);

    glutMainLoop();

    return 0;
}
